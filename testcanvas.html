<!DOCTYPE html>
<html>
<body>

<canvas id="myCanvas" width="800" height="600"
style="border:1px solid #c3c3c3;">
Your browser does not support the canvas element.
</canvas>

<!--script src="https://cdn.jsdelivr.net/gh/nicolaspanel/numjs@0.15.1/dist/numjs.min.js"></script-->
<!--script src="numjs.min.js"></script-->
<script>

UNIT_SIZE_PX = 32  // Size of a default unit in pixels


function abs(x) {
	return x>0? x: -x
}

function sum(arr) {
	var res = 0
	for (var i in arr) res += arr[i]
	return res
}

function dot(a, b) {
	var res = 0
	for (var i in a) res += a[i]*b[i]
	return res
}

function hsum(ns, pows, s){
	var res = 0
	for (var i in ns) res += ns[i] * s**pows[i]
	return res;
}

function max(arr) {
	var res = arr[0]
	for (var i in arr)
		if (arr[i] > res) res = arr[i]
	return res
}

function min(arr) {
	var res = arr[0]
	for (var i in arr)
		if (arr[i] < res) res = arr[i]
	return res
}

class Rect {
	constructor(x, y, w, h) {
		// in pixels
		this.x = x
		this.y = y
		this.w = w
		this.h = h
	}
}

class Container {
	// size in cells
	constructor(w=1, h=1, pow=1) {
		this.w = w
		this.h = h
		this.pow = pow
		this.canvas = undefined
		this.rect = new Rect()
		this.cursor_style = undefined
	}

	draw(canvas, rect) {
		this.canvas = canvas
		this.rect = rect
	}

	hit_test(x, y) {
		var r = this.rect
		return r.x < x && x < r.x+r.w && r.y < y && y < r.y+r.h
	}

	handle_event(event, type) {
		try {
			this[type](event)
			return true
		} catch {
			return false
		}
	}

	onmousemove(event) {
		if (this.onclick && !this.cursor_style) {
			this.cursor_style = "pointer"
		}
		if (this.cursor_style && this.hit_test(event.offsetX, event.offsetY)) {
			this.canvas.style.cursor = this.cursor_style
		}
	}
}

class Layout extends Container {
	children = new Array()
	padding = 0

	_solve_unit(size_px, ns, pows, max_iters=30, tol=0.01) {
		// h = size_px / UNIT_SIZE_PX - total height in units,
		// n_i = ns[i] - hight of each element in cells,
		// s - scale (size of a cell (pow=1) in units),
		// p_i = pows[i] - scale power for each element.
		//
		// We solve the following equation on s:
		// h = sum_i{n_i * s^p_i}
		//
		// Returns size in pixels for each container.
		// The function usually returns in <5us.

		var h = size_px / UNIT_SIZE_PX
		var dhds0 = dot(ns, pows)
		var s0 = h / dhds0
		var h0 = hsum(ns, pows, s0)
		var s1 = s0 - (h0 - h) / dhds0
		s1 = s1<0 ? 0 : s1

		for (var i=0; i<max_iters && s1!=s0 && abs(h0-h)>tol; i++) {
			var h1 = hsum(ns, pows, s1)
			var dhds = (h1-h0) / (s1-s0)
			dhds = 0.9*dhds + 0.1*dhds0  // regularization
			var s2 = s1 - (h1 - h) / dhds
			s0 = s1
			s1 = s2<0 ? 0 : s2
			h0 = h1
		}

		var result = new Array(ns.length)
		for (var i in ns) {
			result[i] = UNIT_SIZE_PX * ns[i] * s1**pows[i]
		}
		return result
	}

	_children_pows() {
		var result = new Array()
		for (var i in this.children) result.push(this.children[i].pow)
		return result
	}

	_children_ws() {
		var result = new Array()
		for (var i in this.children) result.push(this.children[i].w)
		return result
	}

	_children_hs() {
		var result = new Array()
		for (var i in this.children) result.push(this.children[i].h)
		return result
	}

	append(child) {
		this.children.push(child)
	}

	handle_event(event, type) {
		for (var i in this.children) {
			if (this.children[i].hit_test(event.offsetX, event.offsetY) &&
				this.children[i].handle_event(event, type))
			{
				return true
			}
		}
		return false
	}
}

class HBox extends Layout {
	draw(canvas, rect) {
		super.draw(canvas, rect)
		var ns = this._children_ws()
		var pows = this._children_pows()
		var n = this.children.length + 1
		ns.push(this.padding * n)
		pows.push(1)

		var solution = this._solve_unit(rect.w, ns, pows)
		var padding = solution[this.children.length] / n
		var x = rect.x + padding, max_h = 0

		for (var i in this.children) {
			var c = this.children[i]
			c.draw(canvas, new Rect(x, rect.y, solution[i], rect.h))
			x += c.rect.w + padding
			max_h = max([c.rect.h, max_h])
		}

		this.rect.w = x - rect.x
		this.rect.h = max_h
	}
}

class VBox extends Layout {
	draw(canvas, rect) {
		super.draw(canvas, rect)
		var ns = this._children_hs()
		var pows = this._children_pows()
		var n = this.children.length + 1
		ns.push(this.padding * n)
		pows.push(1)

		var solution = this._solve_unit(rect.h, ns, pows)
		var padding = solution[this.children.length] / n
		var y = rect.y + padding, max_w = 0

		for (var i in this.children) {
			var c = this.children[i]
			c.draw(canvas, new Rect(rect.x, y, rect.w, solution[i]))
			y += c.rect.h + padding
			max_w = max([c.rect.w, max_w])
		}

		this.rect.w = max_w
		this.rect.h = y - rect.y
	}
}

class ColorBox extends Container {
	constructor(color="#F0F") {
		super()
		this.color = color
	}

	draw(canvas, rect) {
		super.draw(canvas, rect)
		var ctx = canvas.getContext("2d")
		ctx.fillStyle = this.color
		ctx.fillRect(rect.x, rect.y, rect.w, rect.h)
	}
}

class TextBox extends Container {
	constructor(text="") {
		super()
		this.text = text
	}

	draw(canvas, rect) {
		super.draw(canvas, rect)
		var ctx = canvas.getContext("2d")
		// ctx.fillStyle = '#ff9';
		// ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
		ctx.font = rect.h*0.8 + "px Mono"
		ctx.fillStyle = "black"
		ctx.fillText(this.text, rect.x, rect.y+rect.h*0.8)
	}
}

class ImgBox extends Container {
	constructor(url="") {
		super()
		this.img = new Image()
		this.img.onload = ()=>this._draw_later()
		this.img.src = url
	}

	_draw_later() {
		var ctx = this.canvas.getContext("2d")
		var r = this.rect
		ctx.drawImage(this.img, r.x, r.y, r.w, r.h)
	}

	draw(canvas, rect) {
		super.draw(canvas, rect)
		this._draw_later()
	}
}

class Meter extends Container {
	constructor(data=[], color="#F0F") {
		super()
		this.data = data
		this.color = color
	}

	draw(canvas, rect) {
		super.draw(canvas, rect)
		var ctx = canvas.getContext("2d")
		ctx.fillStyle = "#BBB"
		ctx.fillRect(rect.x, rect.y, rect.w, rect.h)
		ctx.fillStyle = this.color
		if (this.data.length > 1) {
			ctx.beginPath();
			ctx.moveTo(rect.x, rect.y+rect.h);
			var imul = rect.w/(this.data.length-1)
			var vmul = rect.h/max(this.data)
			for (var i in this.data) {
				ctx.lineTo(rect.x + i*imul,
				           rect.y + rect.h - this.data[i]*vmul);
			}
			ctx.lineTo(rect.x+rect.w, rect.y+rect.h);
			ctx.closePath();
			ctx.fill();
		}
	}
}

function space(val=0.1) {
	return new Container({w:val, h:val})
}

class Pod extends HBox {
	uptime = "13h"
	node = "Node67"
	cpu = [0, 0, 0.1, 0.5, 0.2, 0.3, 0.4, 0.5]
	mem = [0, 0, 100,  50,  80, 90,  110, 105]
	status = "Ready"
	padding = 0.1

	constructor() {
		super()
		var vb1 = new VBox()
		vb1.w = 3
		var vb2 = new VBox()
		this.append(vb1)
		this.append(vb2)

		vb1.padding = 0.1
		vb1.append(new TextBox(this.uptime))
		vb1.append(new TextBox(this.node))
		vb1.append(new Meter(this.cpu, "#8F8"))
		vb1.append(new Meter(this.mem, "#88F"))

		vb2.padding = 0.1
		var b1 = new ImgBox("assets/logs.svg")
		b1.onclick = e=>console.log("B1")
		vb2.append(b1)

		var b2 = new ImgBox("assets/exec.svg")
		b2.onclick = e=>console.log("B2")
		vb2.append(b2)

		var b3 = new ImgBox("assets/edit.svg")
		b3.onclick = e=>console.log("B3")
		vb2.append(b3)

		var b4 = new ImgBox("assets/delete.svg")
		b4.cursor_style = "pointer"
		b4.onclick = e=>console.log("B4")
		vb2.append(b4)
	}

	draw(canvas, rect) {
		var ctx = canvas.getContext("2d")
		var colors = {"Waiting": "#FFA", "Ready": "#BFB", "Terminated": "#FBB"}
		ctx.fillStyle = colors[this.status]
		var x = rect.x, y = rect.y, w = min([rect.w, rect.h])
		ctx.fillRect(x, y, w, w)
		super.draw(canvas, new Rect(x, y, w, w))
	}
}

// scene = new Pod()
scene = new HBox()
scene.padding = 0.1
scene.append(new Pod())
scene.append(new Pod())
scene.append(new Pod())
scene.children[1].status = "Waiting"
scene.children[2].status = "Terminated"


var canvas = document.getElementById("myCanvas");
canvas.onwheel = zoom
canvas.onmousemove = shift
// canvas.onclick = scene.children[0].children[1].handle_event
canvas.onclick = e=>scene.handle_event(e, "onclick")

r = new Rect(100, 100, 600, 200)

function redraw() {
	// clear canvas
	var ctx = canvas.getContext("2d");
	ctx.fillStyle = 'white';
	ctx.fillRect(0, 0, canvas.width, canvas.height);

	scene.draw(canvas, r)
}

redraw()

function shift(event) {
	canvas.style.cursor = ""
	if (event.buttons==1 && event.button==0) {
		r.x += event.movementX
		r.y += event.movementY
		redraw()
	} else {
		scene.handle_event(event, "onmousemove")
	}
}

function zoom(event) {
	//console.log(event)
	var k = 1.1
	if (event.deltaY > 0) {
		r.w *= k
		r.h *= k
	} else {
		r.w /= k
		r.h /= k
	}
	redraw()
}

// var ctx = canvas.getContext("2d");
// for (i = 0; i < 10; i++) {
// 	var ctx = canvas.getContext("2d")
// 	ctx.fillStyle = "#FF0000"
// 	ctx.fillRect(100,100,100,100)
// 	ctx.font = "50.176352px Mono"
// 	ctx.fillText("Hello World", 10, 50)
// }
</script>

</body>
</html>